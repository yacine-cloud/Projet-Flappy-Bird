import threading
import serial
import tkinter as tk
import random
import time
from PIL import Image, ImageTk, Image


class FlappyGUI:

    # COMMUNICATION
    def init_serial_thread(self):
        """Initialise le port série"""
        try:
            self.ser = serial.Serial('COM4', 9600, timeout=0.1)
        except serial.SerialException:
            print("Erreur : impossible d'ouvrir le port série COM4")
            return

        if self.current_mode:
            # Envoie le mode choisi au PIC
            command_to_send = f"MODE:{self.current_mode.upper()}\n"
            self.ser.write(command_to_send.encode())
            print(f"Envoyé au PIC : {command_to_send.strip()}")

        self.serial_thread_stop = threading.Event()
        self.serial_thread = threading.Thread(target=self.read_pic, daemon=True)
        self.serial_thread.start()

    def stop_serial_thread(self):
        if hasattr(self, 'serial_thread_stop') and self.serial_thread_stop:
            self.serial_thread_stop.set()
        if hasattr(self, 'serial_thread') and self.serial_thread and self.serial_thread.is_alive():
            self.serial_thread.join(timeout=0.1)
        if hasattr(self, 'ser') and self.ser and self.ser.is_open:
            self.ser.close()
            print("Port série fermé.")

    def read_pic(self):
        """Boucle de lecture des commandes PIC"""
        while not self.serial_thread_stop.is_set():
            if hasattr(self, 'ser') and self.ser and self.ser.in_waiting:
                try:
                    line = self.ser.readline().decode().strip()
                    if not line:
                        continue

                    # Dispatcher les commandes
                    if line == "FLAP":
                        # Pour le mode bouton ou ultrasons
                        self.root.after(0, self.on_space_press, None)

                    elif line.startswith("VAL:"):
                        # Valeur analogique pour infrarouge ou ultrasons
                        try:
                            val = int(line.split(":")[1])
                            self.root.after(0, lambda v=val: self.infrared(v))
                        except ValueError:
                            pass

                    elif line.startswith("ENCODER:"):
                        # Donnée envoyée par Yacine : "ENCODER:LEFT" ou "ENCODER:RIGHT"
                        direction = line.split(":")[1].strip().upper()
                        self.root.after(0, lambda d=direction: self.handle_encoder(d))


                except Exception as e:
                    print(f"Erreur lecture série : {e}")
                    break
            else:
                threading.Event().wait(0.01)

    # INITIALISATION
    def __init__(self, root):
        self.root = root
        self.root.title("Flappy Goku")
        self.root.attributes("-fullscreen", True)
        self.root.bind("<Escape>", lambda e: self.root.destroy())

        self.best_scores = {
            "push_button": 0, "encoder": 0, "ultrasound": 0, "infrared": 0
        }
        self.current_mode = None

        self.blink_after_id = None
        self.game_loop_id = None
        self.goku_hover_id = None
        self.db_loop_id = None

        # Variables de jeu
        self.is_paused = False
        self.is_replay = False
        self.game_start_time = 0
        self.current_replay_data = []
        self.last_replay_data = []
        self.replay_index = 0

        self.smooth_y = None

        self.ser = None
        self.serial_thread = None
        self.serial_thread_stop = None

        self.start_page()

    # Menu
    def toggle_press_start_text(self):
        """Fait clignoter le texte 'Press Start'"""
        if hasattr(self, 'canvas') and self.canvas.winfo_exists() and hasattr(self, 'press_to_start_text'):
            if self.press_start_visible:
                self.canvas.itemconfig(self.press_to_start_text, state='hidden')
            else:
                self.canvas.itemconfig(self.press_to_start_text, state='normal')
            self.press_start_visible = not self.press_start_visible
            self.blink_after_id = self.root.after(500, self.toggle_press_start_text)

    def animate_goku_hover(self):
        """Animation de Goku sur le menu"""
        if hasattr(self, 'goku_hover_sprite') and self.canvas.winfo_exists():
            self.goku_hover_step += self.goku_hover_direction
            self.canvas.move(self.goku_hover_sprite, 0, self.goku_hover_direction * 2)
            if abs(self.goku_hover_step) > 10:
                self.goku_hover_direction *= -1
            self.goku_hover_id = self.root.after(50, self.animate_goku_hover)

    #Modes
    #Infrarouge
    def infrared(self, val):
        """Contrôle par capteur infrarouge : plus la main est proche, plus Goku monte"""
        if self.is_paused or self.is_replay or not hasattr(self, 'bird') or not self.canvas.winfo_exists():
            return

        val_min = 70
        val_max = 400
        val = max(min(val, val_max), val_min)

        # Calcul de la "force de flap" selon la distance
        ratio = 1 - (val - val_min) / (val_max - val_min)
        flap_power = (ratio - 0.5) * 30  # varie entre -15 et +15

        # Appliquer une impulsion verticale (comme un flap doux)
        self.velocity = -flap_power

        elapsed = time.time() - self.game_start_time
        coords = self.canvas.coords(self.bird)
        if coords:
            self.current_replay_data.append((elapsed, coords[1]))


#encoder
    def handle_encoder(self, data):
        """Déplacement vertical avec encodeur"""
        if not self.bird or not self.canvas.winfo_exists():
            return
        step = 30  # déplacement en pixels
        if data == "LEFT":  # tourner à gauche → monter
            self.bird_y = max(0, self.bird_y - step)
        elif data == "RIGHT":  # tourner à droite → descendre
            self.bird_y = min(self.screen_height - self.bird_size - 50, self.bird_y + step)
        self.canvas.coords(self.bird, self.bird_x, self.bird_y)
        
#ultrasons
#JOUER

    def start_page(self):
        self.clear()
        self.canvas = tk.Canvas(self.root, highlightthickness=0)
        self.canvas.pack(fill="both", expand=True)
        screen_w = self.root.winfo_screenwidth()
        screen_h = self.root.winfo_screenheight()

        bg_img = Image.open("fond.png").resize((screen_w, screen_h), Image.Resampling.LANCZOS)
        self.bg_start_img = ImageTk.PhotoImage(bg_img)
        self.canvas.create_image(0, 0, anchor="nw", image=self.bg_start_img)

        overlay = Image.new("RGBA", (500, 450), (20, 30, 70, 180))
        self.overlay_img = ImageTk.PhotoImage(overlay)
        self.canvas.create_image(screen_w / 2, screen_h / 2, image=self.overlay_img, anchor="center")

        self.canvas.create_text(screen_w / 2, screen_h / 2 - 170, text="Flappy Goku", font=("Arial", 40, "bold"),
                                fill="white")
        self.press_to_start_text = self.canvas.create_text(screen_w / 2, screen_h / 2 - 100, text="Press Start",
                                                           font=("Arial", 22, "bold"), fill="#FFD700")
        self.press_start_visible = True
        self.toggle_press_start_text()

        img = Image.open("goku2.png").resize((150, 150), Image.Resampling.LANCZOS)
        self.goku_hover_img = ImageTk.PhotoImage(img)
        self.goku_hover_sprite = self.canvas.create_image(screen_w // 2 - 400, screen_h // 2, image=self.goku_hover_img)
        self.goku_hover_step = 0
        self.goku_hover_direction = 1
        self.animate_goku_hover()

        btn_style = {"font": ("Arial", 16, "bold"), "relief": "flat", "padx": 15, "pady": 5, "width": 12}
        btn_play = tk.Button(self.root, text="Play", **btn_style, bg="#FFD700", fg="black", activebackground="#FFFF99",
                             command=self.select_mode_page)
        btn_inst = tk.Button(self.root, text="Instructions", **btn_style, bg="#FFA500", fg="black",
                             activebackground="#FFC966", command=self.regle)
        btn_replay = tk.Button(self.root, text="Replay", **btn_style, bg="#4CAF50", fg="white",
                               activebackground="#8BC34A", command=self.replay_game_page)
        btn_quit = tk.Button(self.root, text="Quitter", **btn_style, bg="#FF4C4C", fg="white",
                             activebackground="#FF8888", command=self.quit_game)

        self.canvas.create_window(screen_w / 2, screen_h / 2 - 30, window=btn_play)
        self.canvas.create_window(screen_w / 2, screen_h / 2 + 30, window=btn_inst)
        self.canvas.create_window(screen_w / 2, screen_h / 2 + 90, window=btn_replay)
        self.canvas.create_window(screen_w / 2, screen_h / 2 + 150, window=btn_quit)

        for btn in [btn_play, btn_inst, btn_replay, btn_quit]:
            btn.bind("<Enter>", lambda e, b=btn: b.config(font=("Arial", 18, "bold")))
            btn.bind("<Leave>", lambda e, b=btn: b.config(font=("Arial", 16, "bold")))

    def select_mode_page(self):
        self.clear()
        screen_w = self.root.winfo_screenwidth()
        screen_h = self.root.winfo_screenheight()
        bg_img = Image.open("fond.png").resize((screen_w, screen_h), Image.Resampling.LANCZOS)
        self.bg_select_img = ImageTk.PhotoImage(bg_img)
        self.canvas = tk.Canvas(self.root, highlightthickness=0)
        self.canvas.pack(fill="both", expand=True)
        self.canvas.create_image(0, 0, anchor="nw", image=self.bg_select_img)

        overlay = Image.new("RGBA", (600, 550), (20, 30, 70, 180))
        self.overlay_select_img = ImageTk.PhotoImage(overlay)
        self.canvas.create_image(screen_w / 2, screen_h / 2, image=self.overlay_select_img, anchor="center")
        self.canvas.create_text(screen_w // 2, screen_h // 2 - 200, text="Sélection du Mode",
                                font=("Arial", 32, "bold"), fill="white")

        btn_style = {"font": ("Arial", 16, "bold"), "relief": "flat", "padx": 15, "pady": 5, "width": 18}

        btn1 = tk.Button(self.root, text="Push Button", **btn_style, bg="#3C00FF", fg="white",
                         activebackground="#6040FF", command=lambda: self.start_game("push_button"))
        btn2 = tk.Button(self.root, text="Digital Encoder", **btn_style, bg="#4CAF50", fg="white",
                         activebackground="#8BC34A", command=lambda: self.start_game("encoder"))
        btn3 = tk.Button(self.root, text="Ultrasound Sensor", **btn_style, bg="#FFA500", fg="black",
                         activebackground="#FFC966", command=lambda: self.start_game("ultrasound"))
        btn4 = tk.Button(self.root, text="Infrared Sensor", **btn_style, bg="#FFD700", fg="black",
                         activebackground="#FFFF99", command=lambda: self.start_game("infrared"))
        btn5 = tk.Button(self.root, text="Retour", **btn_style, bg="#FF4C4C", fg="white", activebackground="#FF8888",
                         command=self.start_page)

        self.canvas.create_window(screen_w // 2, screen_h // 2 - 100, window=btn1)
        self.canvas.create_window(screen_w // 2, screen_h // 2 - 40, window=btn2)
        self.canvas.create_window(screen_w // 2, screen_h // 2 + 20, window=btn3)
        self.canvas.create_window(screen_w // 2, screen_h // 2 + 80, window=btn4)
        self.canvas.create_window(screen_w // 2, screen_h // 2 + 180, window=btn5)

        for btn in [btn1, btn2, btn3, btn4, btn5]:
            btn.bind("<Enter>", lambda e, b=btn: b.config(font=("Arial", 18, "bold")))
            btn.bind("<Leave>", lambda e, b=btn: b.config(font=("Arial", 16, "bold")))

    def regle(self):
        self.clear()
        screen_w = self.root.winfo_screenwidth()
        screen_h = self.root.winfo_screenheight()
        self.canvas = tk.Canvas(self.root, highlightthickness=0)
        self.canvas.pack(fill="both", expand=True)

        try:
            bg_img = Image.open("fondregles.png").resize((screen_w, screen_h), Image.Resampling.LANCZOS)
            self.bg_regle_img = ImageTk.PhotoImage(bg_img)
            self.canvas.create_image(0, 0, anchor="nw", image=self.bg_regle_img)
        except FileNotFoundError:
            self.canvas.config(bg="#2196F3")

        overlay = Image.new("RGBA", (int(screen_w * 0.55), int(screen_h * 0.5)), (0, 0, 0, 160))
        self.overlay_regle_img = ImageTk.PhotoImage(overlay)
        self.canvas.create_image(screen_w / 2, screen_h / 2, image=self.overlay_regle_img, anchor="center")

        self.canvas.create_text(screen_w / 2, screen_h * 0.28, text="Comment Jouer", font=("Arial", 32, "bold"),
                                fill="#FFD700")
        self.canvas.create_text(screen_w / 2, screen_h * 0.36,
                                text="Le but du jeu est simple :\nFais voler Goku sans qu’il touche les Kamehameha !",
                                font=("Arial", 16, "italic"), fill="white", justify="center")
        self.canvas.create_text(screen_w / 2, screen_h * 0.5,
                                text="• Push Button : Appuie sur le bouton pour voler.\n• Digital Encoder : Tourne l'encodeur pour voler.\n• Ultrasound Sensor : Passe ta main au-dessus.\n• Infrared Sensor : Passe ta main devant.",
                                font=("Arial", 18), fill="white", justify="left")
        self.canvas.create_text(screen_w / 2, screen_h * 0.64,
                                text="Si tu touches le sol ou un Kamehameha, c’est perdu !",
                                font=("Arial", 16, "italic"), fill="white", justify="center")

        btn_retour = tk.Button(self.root, text="Retour au menu", font=("Arial", 16, "bold"), bg="#FFD700", fg="black",
                               relief="flat", activebackground="#FFFF99", command=self.start_page)
        self.canvas.create_window(screen_w / 2, screen_h * 0.73, window=btn_retour)

    def replay_game_page(self):
        if not self.last_replay_data:
            self.start_page()
            return

        self.clear()
        self.is_replay = True
        self.is_paused = False
        self.replay_index = 0
        self.game_start_time = time.time()

        self.canvas = tk.Canvas(self.root, highlightthickness=0)
        self.canvas.pack(fill="both", expand=True)
        self.screen_width = self.root.winfo_screenwidth()
        self.screen_height = self.root.winfo_screenheight()
        bg_img = Image.open("fond.png").resize((self.screen_width, self.screen_height), Image.Resampling.LANCZOS)
        self.bg_img = ImageTk.PhotoImage(bg_img)
        self.canvas.create_image(0, 0, anchor="nw", image=self.bg_img)
        self.ground = self.canvas.create_rectangle(0, self.screen_height - 50, self.screen_width, self.screen_height,
                                                   fill="#DEB887", outline="")
        self.bird_size = 100
        self.bird_x = 200
        # Position de départ pour le replay
        start_y = self.last_replay_data[0][1] if self.last_replay_data else self.screen_height // 2
        self.bird_img = ImageTk.PhotoImage(
            Image.open("goku2.png").resize((self.bird_size, self.bird_size), Image.Resampling.LANCZOS))
        self.bird = self.canvas.create_image(self.bird_x, start_y, anchor="nw", image=self.bird_img)

        self.pipes = []
        self.pipe_images = []
        x = self.bird_x + 500
        for i in range(5):
            self.create_pipe(x)
            x += random.randint(250, 400)

        self.passed_dict = {pipe[0]: True for pipe in self.pipes}
        self.canvas.create_text(self.screen_width / 2, 50, text="REPLAY X2", font=("Arial", 30, "bold"), fill="red")

        self.game_loop_id = self.canvas.after(15, self.update_game)

    def start_game(self, mode):
        self.current_mode = mode
        self.game_page()
        self.init_serial_thread()

    def game_page(self):
        self.clear()
        self.is_paused = False
        self.is_replay = False
        self.current_replay_data = []
        self.game_start_time = time.time()
        self.smooth_y = None

        self.canvas = tk.Canvas(self.root, highlightthickness=0)
        self.canvas.pack(fill="both", expand=True)
        self.screen_width = self.root.winfo_screenwidth()
        self.screen_height = self.root.winfo_screenheight()

        bg_img = Image.open("fond.png").resize((self.screen_width, self.screen_height), Image.Resampling.LANCZOS)
        self.bg_img = ImageTk.PhotoImage(bg_img)
        self.canvas.create_image(0, 0, anchor="nw", image=self.bg_img)

        self.ground = self.canvas.create_rectangle(0, self.screen_height - 50, self.screen_width, self.screen_height,
                                                   fill="#DEB887", outline="")

        self.bird_size = 100
        self.bird_x = 200
        self.bird_y = self.screen_height // 2
        img = Image.open("goku2.png").resize((self.bird_size, self.bird_size), Image.Resampling.LANCZOS)
        self.bird_img = ImageTk.PhotoImage(img)
        self.bird = self.canvas.create_image(self.bird_x, self.bird_y, anchor="nw", image=self.bird_img)

        self.pipes = []
        self.pipe_images = []
        x = self.bird_x + 500
        for i in range(5):
            self.create_pipe(x)
            x += random.randint(250, 400)

        self.passed_dict = {pipe[0]: False for pipe in self.pipes}
        self.score = 0
        self.score_text = self.canvas.create_text(self.screen_width - 50, 50, text=f"Score: 0",
                                                  font=("Arial", 24, "bold"), fill="white", anchor="ne")

        self.velocity = 0
        self.gravity = 1
        self.flap_strength = -15

        self.root.bind("<space>", self.on_space_press)
        self.game_loop_id = self.canvas.after(30, self.update_game)
#OBSTACLES
    def create_pipe(self, x):
        gap = random.randint(180, 250)
        top_h = random.randint(100, self.screen_height - gap - 100)
        bottom_y = top_h + gap
        img_top = ImageTk.PhotoImage(Image.open("tuyau1.png").resize((100, top_h), Image.Resampling.LANCZOS))
        img_bot = ImageTk.PhotoImage(
            Image.open("tuyau2.png").resize((100, self.screen_height - bottom_y), Image.Resampling.LANCZOS))
        top = self.canvas.create_image(x, 0, anchor="nw", image=img_top)
        bot = self.canvas.create_image(x, bottom_y, anchor="nw", image=img_bot)
        self.pipes.append((top, bot))
        self.pipe_images.extend([img_top, img_bot])

    def move_pipes(self):
        speed = 16 if self.is_replay else 8
        bird_coords = self.canvas.coords(self.bird)
        if not bird_coords:
            return
        bird_x = bird_coords[0]

        # Déplacement + scoring
        for top, bot in list(self.pipes):
            self.canvas.move(top, -speed, 0)
            self.canvas.move(bot, -speed, 0)

            # Mise à jour du score
            if not self.is_replay and not self.passed_dict.get(top, False) and self.canvas.coords(top)[
                0] + 100 < bird_x:
                self.score += 1
                self.canvas.itemconfigure(self.score_text, text=f"Score: {self.score}")
                self.passed_dict[top] = True

        # Suppression et création des nouveaux tuyaux
        if self.pipes and self.canvas.coords(self.pipes[0][0]) and self.canvas.coords(self.pipes[0][0])[0] < -100:
            try:
                top, bot = self.pipes.pop(0)
                self.canvas.delete(top)
                self.canvas.delete(bot)
            except Exception as e:
                print("Erreur suppression tuyaux :", e)
                return

            # Vérifie qu'il reste bien au moins un tuyau avant de calculer le nouveau X
            if self.pipes and self.canvas.coords(self.pipes[-1][0]):
                last_x = self.canvas.coords(self.pipes[-1][0])[0]
                new_x = last_x + random.randint(250, 400)
                self.create_pipe(new_x)
            else:
                print("Aucun tuyau restant, recréation forcée...")
                self.pipes = []
                start_x = self.bird_x + 500
                for i in range(5):
                    self.create_pipe(start_x + i * 300)

    def check_collision(self):
        bx1, by1, bx2, by2 = self.canvas.bbox(self.bird)
        if by1 <= 0 or by2 >= self.screen_height - 50: return True
        for top, bot in self.pipes:
            tx1, ty1, tx2, ty2 = self.canvas.bbox(top)
            bx1_p, by1_p, bx2_p, by2_p = self.canvas.bbox(bot)
            if (bx2 - 30 > tx1 + 20 and bx1 + 30 < tx2 - 20 and by1 + 30 < ty2 - 20) or \
                    (bx2 - 30 > bx1_p + 20 and bx1 + 30 < bx2_p - 20 and by2 - 30 > by1_p + 20):
                return True
        return False

    def update_game(self):
        if self.is_paused:
            self.game_loop_id = self.canvas.after(30, self.update_game)
            return

        if self.is_replay:
            # Logique Replay
            elapsed = (time.time() - self.game_start_time) * 2
            while self.replay_index < len(self.last_replay_data) - 1 and self.last_replay_data[self.replay_index + 1][
                0] < elapsed:
                self.replay_index += 1
            if self.replay_index < len(self.last_replay_data):
                self.canvas.coords(self.bird, self.bird_x, self.last_replay_data[self.replay_index][1])
        else:
            # === Physique universelle ===
            self.velocity += self.gravity
            self.canvas.move(self.bird, 0, self.velocity)

            # Clamp de position
            coords = self.canvas.coords(self.bird)
            if coords:
                y = coords[1]
                if y < 0:
                    self.canvas.coords(self.bird, self.bird_x, 0)
                    self.velocity = 0
                elif y > self.screen_height - 50 - self.bird_size:
                    self.canvas.coords(self.bird, self.bird_x, self.screen_height - 50 - self.bird_size)
                    self.velocity = 0

                # Enregistre la position pour le replay
                self.current_replay_data.append((time.time() - self.game_start_time, y))

        self.move_pipes()
        if self.check_collision() or (self.is_replay and self.replay_index >= len(self.last_replay_data) - 1):
            if self.is_replay:
                self.root.after(1000, self.start_page)
            else:
                self.end_game()
        else:
            delay = 15 if self.is_replay else 30
            self.game_loop_id = self.canvas.after(delay, self.update_game)

    def end_game(self):
        if self.game_loop_id: self.canvas.after_cancel(self.game_loop_id)

        if not self.is_replay:
            self.last_replay_data = self.current_replay_data
            self.last_replay_mode = self.current_mode

        if self.current_mode and self.score > self.best_scores[self.current_mode]:
            self.best_scores[self.current_mode] = self.score

        self.clear()
        self.canvas = tk.Canvas(self.root, highlightthickness=0)
        self.canvas.pack(fill="both", expand=True)
        screen_w = self.root.winfo_screenwidth()
        screen_h = self.root.winfo_screenheight()
        bg_img = Image.open("fond.png").resize((screen_w, screen_h), Image.Resampling.LANCZOS)
        self.bg_over_img = ImageTk.PhotoImage(bg_img)
        self.canvas.create_image(0, 0, anchor="nw", image=self.bg_over_img)
        overlay = Image.new("RGBA", (500, 450), (0, 0, 0, 180))
        self.overlay_go = ImageTk.PhotoImage(overlay)
        self.canvas.create_image(screen_w / 2, screen_h / 2, image=self.overlay_go, anchor="center")

        self.canvas.create_text(screen_w / 2, screen_h / 2 - 140, text="Game Over", font=("Arial", 40, "bold"),
                                fill="white")
        self.canvas.create_text(screen_w / 2, screen_h / 2 - 80, text=f"Score : {self.score}",
                                font=("Arial", 24, "bold"), fill="white")
        self.canvas.create_text(screen_w / 2, screen_h / 2 - 40,
                                text=f"Best ({self.current_mode}) : {self.best_scores.get(self.current_mode, 0)}",
                                font=("Arial", 24, "bold"), fill="white")

        btn_style = {"font": ("Arial", 16, "bold"), "relief": "flat", "padx": 15, "pady": 5, "width": 15}
        tk.Button(self.root, text="Restart", **btn_style, bg="#4CAF50", fg="white",
                  command=lambda: self.start_game(self.current_mode)).place(x=screen_w / 2, y=screen_h / 2 + 40,
                                                                            anchor="center")
        tk.Button(self.root, text="Menu", **btn_style, bg="#FFD700", fg="black", command=self.start_page).place(
            x=screen_w / 2, y=screen_h / 2 + 100, anchor="center")
        tk.Button(self.root, text="Quitter", **btn_style, bg="#FF4C4C", fg="white", command=self.quit_game).place(
            x=screen_w / 2, y=screen_h / 2 + 160, anchor="center")

    def on_space_press(self, event):
        if not self.is_paused and not self.is_replay and self.current_mode in ["push_button", "encoder"]:
            self.velocity = self.flap_strength

    def quit_game(self):
        self.clear()
        self.root.destroy()

    def clear(self):
        if self.blink_after_id: self.root.after_cancel(self.blink_after_id); self.blink_after_id = None
        if self.game_loop_id: self.root.after_cancel(self.game_loop_id); self.game_loop_id = None
        if self.goku_hover_id: self.root.after_cancel(self.goku_hover_id); self.goku_hover_id = None
        self.stop_serial_thread()
        for widget in self.root.winfo_children():
            widget.destroy()


if __name__ == "__main__":
    root = tk.Tk()
    app = FlappyGUI(root)
    root.mainloop()
