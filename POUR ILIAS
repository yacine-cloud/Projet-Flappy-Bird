import threading
import serial
import tkinter as tk
import random
import time
from PIL import Image, ImageTk, Image


class FlappyGUI:

    # COMMUNICATION
    def init_serial_thread(self):
        print("init_serial_thread appel√©e")
        try:
            print(" Tentative ouverture COM4")
            self.ser = serial.Serial('COM4', 9600, timeout=0.1)
            print("Port ouvert :", self.ser.port)

            if hasattr(self, "current_mode") and self.current_mode:
                        # Conversion du mode Python ‚Üí format PIC
                        mode_map = {
                            "push_button": "PUSHBUTTON",
                            "encoder": "ENCODER",
                            "ultrasound": "ULTRASOUND",
                            "infrared": "INFRARED"
                        }
                        mode_str = mode_map.get(self.current_mode, self.current_mode.upper())
                        msg = f"MODE:{mode_str}\n"
                        print(f" Envoi du mode au PIC : {msg.strip()}")
                        self.ser.write(msg.encode())


        except Exception as e:
            print(" Erreur ouverture port :", e)
            return

        print(" Cr√©ation thread s√©rie...")
        self.serial_thread_stop = threading.Event()
        self.serial_thread = threading.Thread(target=self.read_pic, daemon=True)
        self.serial_thread.start()
        print("Thread s√©rie lanc√©")


    def stop_serial_thread(self):
        """Arr√™te le thread s√©rie"""
        if hasattr(self, 'serial_thread_stop') and self.serial_thread_stop:
            self.serial_thread_stop.set()
        if hasattr(self, 'serial_thread') and self.serial_thread and self.serial_thread.is_alive():
            self.serial_thread.join(timeout=0.1)
        if hasattr(self, 'ser') and self.ser and self.ser.is_open:
            self.ser.close()
            print("Port s√©rie ferm√©.")

    def read_pic(self):
            """Boucle de lecture non bloquante des donn√©es PIC"""
            while not self.serial_thread_stop.is_set():
                try:
                    if not hasattr(self, 'ser') or not self.ser or not self.ser.is_open:
                        break

                    line = self.ser.readline().decode(errors='ignore').strip()

                    if line:
                        clean = line.strip().upper()  # üîπ supprime \r \n et majuscules
                    # --- GESTION DES COMMANDES ---
                        if clean in ("F", "FL", "FLA", "FLAP"):
                            print("üî• Signal FLAP d√©tect√© depuis le PIC !")
                            self.root.after(0, self.on_space_press, None)

                        elif line == "LEFT":
                            self.root.after(0, lambda: self.encoder("LEFT"))

                        elif line == "RIGHT":
                            self.root.after(0, lambda: self.encoder("RIGHT"))

                        elif line.startswith("ULTRA:"):
                            if self.current_mode == "ultrasound":
                                cm = int(''.join(filter(str.isdigit, line)))
                                self.root.after(0, lambda v=cm: self.ultrasound(v))
                            else:
                                print(f"Ignor√© (mode {self.current_mode}) : {line}")

                        elif line.replace(" ", "").isdigit():
                            try:
                                val = int(line.strip().lstrip('0') or '0')
                                self.root.after(0, lambda v=val: self.infrared(v))
                            except Exception as e:
                                print("Erreur conversion valeur capteur:", e)



                # pause courte pour √©viter d'occuper le CPU
                    time.sleep(0.02)

                except serial.SerialException as e:
                    print(f" Port s√©rie d√©connect√© : {e}")
                    break
                except Exception as e:
                    print(f" Erreur dans thread s√©rie : {e}")
                    time.sleep(0.1)
                print(f" Re√ßu: {line} | Mode actuel: {self.current_mode}")


    # INITIALISATION
    def __init__(self, root):
        self.root = root
        self.root.title("Flappy Goku")
        self.root.attributes("-fullscreen", True)
        self.root.bind("<Escape>", lambda e: self.root.destroy())

        self.best_scores = {
            "push_button": 0, "encoder": 0, "ultrasound": 0, "infrared": 0
        }
        self.current_mode = None

        self.blink_after_id = None
        self.game_loop_id = None
        self.goku_hover_id = None
        self.db_loop_id = None

        # Variables de jeu
        self.is_paused = False
        self.is_replay = False
        self.game_start_time = 0
        self.current_replay_data = []  # Stocke (temps, y_pos) ou (temps, 'flap')
        self.last_replay_data = []
        self.replay_index = 0

        # --- AJOUT POUR TON CAPTEUR ---
        self.smooth_y = None

        self.ser = None
        self.serial_thread = None
        self.serial_thread_stop = None

        self.start_page()

    # --- TA NOUVELLE FONCTION INS√âR√âE ICI ---
    def infrared(self, val):
        """Met √† jour la position de Goku selon la distance main-capteur (IR/US)"""
        if self.is_paused or self.is_replay or not hasattr(self, 'bird') or not self.canvas.winfo_exists():
            return

        # --- Calibration (√† ajuster selon ton capteur) ---
        val_min = 200   # main √©loign√©e ‚Üí bas
        val_max = 420    # main proche ‚Üí haut

        # Clamp (bloque entre min et max)
        val = max(min(val, val_max), val_min)

        # Zone morte (√©vite de tout bouger quand √ßa tremble)
        if abs(val - getattr(self, "last_val", val)) < 5:
            return
        self.last_val = val

        # --- Mapping vers la hauteur de l‚Äô√©cran ---
        y_min = 0
        y_max = self.screen_height - 120
        ratio = 1 - (val - val_min) / (val_max - val_min)
        y_target = y_min + ratio * (y_max - y_min)

        # --- Mouvement plus fluide ---
        if not hasattr(self, "smooth_y") or self.smooth_y is None:
            self.smooth_y = y_target
        self.smooth_y = 0.85 * self.smooth_y + 0.15 * y_target

        # --- Appliquer la position ---
        self.canvas.coords(self.bird, self.bird_x, self.smooth_y)

        # --- Enregistrer la position pour le replay ---
        elapsed = time.time() - self.game_start_time
        self.current_replay_data.append((elapsed, self.smooth_y))

    def encoder(self, direction):
        """D√©placement du personnage avec l'encodeur"""
        if not hasattr(self, 'bird') or not self.canvas.winfo_exists():
            return
        if direction == "LEFT":
            self.canvas.move(self.bird, 0, 25)
        elif direction == "RIGHT":
            self.canvas.move(self.bird, 0, -25)



    def ultrasound(self, val_cm):
        if self.is_paused or self.is_replay or not hasattr(self, 'bird') or not self.canvas.winfo_exists():
            return

        seuil_cm = 43        # main plus proche que √ßa => on saute
        hysteresis = 5       # √©vite de resauter quand c‚Äôest proche du seuil
        now = time.time()
        cooldown = 0.18      # minimum entre deux flaps

        if not hasattr(self, "last_ultra_time"):
            self.last_ultra_time = 0
            self.last_state_near = False

        # D√©tection approche main
        if val_cm < seuil_cm - hysteresis and not self.last_state_near and (now - self.last_ultra_time) > cooldown:
            print(f" FLAP d√©tect√© √† {val_cm} cm")
            self.last_ultra_time = now
            self.last_state_near = True
            self.root.after(0, lambda: self.on_space_press(None))

        # Si la main repart loin ‚Üí on r√©arme le capteur
        elif val_cm > seuil_cm + hysteresis:
            self.last_state_near = False


 # --- ENVOI DU SCORE AU PIC ---
    def send_score_to_pic(self):
        """Envoie le score actuel au PIC pour affichage sur 7 segments"""
        try:
            if hasattr(self, 'ser') and self.ser and self.ser.is_open:
                message = f"BUF:SCORE={self.score:02d}\n"
                self.ser.write(message.encode())
                print(f"[DEBUG] Score envoy√© au PIC : {message.strip()}")
        except Exception as e:
            print(f"Erreur envoi score au PIC : {e}")






    def toggle_press_start_text(self):
        if hasattr(self, 'canvas') and self.canvas.winfo_exists() and hasattr(self, 'press_to_start_text'):
            state = self.canvas.itemcget(self.press_to_start_text, 'state')
            new_state = 'hidden' if state == 'normal' else 'normal'
            self.canvas.itemconfig(self.press_to_start_text, state=new_state)
            self.blink_after_id = self.root.after(500, self.toggle_press_start_text)

    def animate_goku_hover(self):
        if hasattr(self, 'goku_hover_sprite') and self.canvas.winfo_exists():
            self.goku_hover_step += self.goku_hover_direction
            self.canvas.move(self.goku_hover_sprite, 0, self.goku_hover_direction * 2)
            if abs(self.goku_hover_step) > 10:
                self.goku_hover_direction *= -1
            self.goku_hover_id = self.root.after(50, self.animate_goku_hover)

    def start_page(self):
        self.clear()
        self.canvas = tk.Canvas(self.root, highlightthickness=0)
        self.canvas.pack(fill="both", expand=True)
        screen_w = self.root.winfo_screenwidth()
        screen_h = self.root.winfo_screenheight()

        bg_img = Image.open("fond.png").resize((screen_w, screen_h), Image.Resampling.LANCZOS)
        self.bg_start_img = ImageTk.PhotoImage(bg_img)
        self.canvas.create_image(0, 0, anchor="nw", image=self.bg_start_img)

        overlay = Image.new("RGBA", (500, 450), (20, 30, 70, 180))
        self.overlay_img = ImageTk.PhotoImage(overlay)
        self.canvas.create_image(screen_w / 2, screen_h / 2, image=self.overlay_img, anchor="center")

        self.canvas.create_text(screen_w / 2, screen_h / 2 - 170, text="Flappy Goku", font=("Arial", 40, "bold"),
                                fill="white")
        self.press_to_start_text = self.canvas.create_text(screen_w / 2, screen_h / 2 - 100, text="Press Start",
                                                           font=("Arial", 22, "bold"), fill="#FFD700")
        self.toggle_press_start_text()

        img = Image.open("goku2.png").resize((150, 150), Image.Resampling.LANCZOS)
        self.goku_hover_img = ImageTk.PhotoImage(img)
        self.goku_hover_sprite = self.canvas.create_image(screen_w // 2 - 400, screen_h // 2, image=self.goku_hover_img)
        self.goku_hover_step = 0
        self.goku_hover_direction = 1
        self.animate_goku_hover()

        btn_style = {"font": ("Arial", 16, "bold"), "relief": "flat", "padx": 15, "pady": 5, "width": 12}
        btn_play = tk.Button(self.root, text="Play", **btn_style, bg="#FFD700", fg="black", activebackground="#FFFF99",
                             command=self.select_mode_page)
        btn_inst = tk.Button(self.root, text="Instructions", **btn_style, bg="#FFA500", fg="black",
                             activebackground="#FFC966", command=self.regle)
        btn_replay = tk.Button(self.root, text="Replay", **btn_style, bg="#4CAF50", fg="white",
                               activebackground="#8BC34A", command=self.replay_game_page)
        btn_quit = tk.Button(self.root, text="Quitter", **btn_style, bg="#FF4C4C", fg="white",
                             activebackground="#FF8888", command=self.quit_game)

        self.canvas.create_window(screen_w / 2, screen_h / 2 - 30, window=btn_play)
        self.canvas.create_window(screen_w // 2, screen_h / 2 + 30, window=btn_inst)
        self.canvas.create_window(screen_w // 2, screen_h / 2 + 90, window=btn_replay)
        self.canvas.create_window(screen_w / 2, screen_h / 2 + 150, window=btn_quit)

    def select_mode_page(self):
        self.clear()
        screen_w = self.root.winfo_screenwidth()
        screen_h = self.root.winfo_screenheight()
        bg_img = Image.open("fond.png").resize((screen_w, screen_h), Image.Resampling.LANCZOS)
        self.bg_select_img = ImageTk.PhotoImage(bg_img)
        self.canvas = tk.Canvas(self.root, highlightthickness=0)
        self.canvas.pack(fill="both", expand=True)
        self.canvas.create_image(0, 0, anchor="nw", image=self.bg_select_img)

        overlay = Image.new("RGBA", (600, 550), (20, 30, 70, 180))
        self.overlay_select_img = ImageTk.PhotoImage(overlay)
        self.canvas.create_image(screen_w / 2, screen_h / 2, image=self.overlay_select_img, anchor="center")
        self.canvas.create_text(screen_w // 2, screen_h // 2 - 200, text="S√©lection du Mode",
                                font=("Arial", 32, "bold"), fill="white")

        btn_style = {"font": ("Arial", 16, "bold"), "relief": "flat", "padx": 15, "pady": 5, "width": 18}
        # On passe le nom EXACT du mode pour qu'il soit reconnu plus tard
        tk.Button(self.root, text="Push Button", **btn_style, bg="#3C00FF", fg="white", activebackground="#6040FF",
                  command=lambda: self.start_game("push_button")).place(x=screen_w // 2, y=screen_h // 2 - 100,
                                                                        anchor="center")
        tk.Button(self.root, text="Digital Encoder", **btn_style, bg="#4CAF50", fg="white", activebackground="#8BC34A",
                  command=lambda: self.start_game("encoder")).place(x=screen_w // 2, y=screen_h // 2 - 40,
                                                                    anchor="center")
        tk.Button(self.root, text="Ultrasound Sensor", **btn_style, bg="#FFA500", fg="black",
                  activebackground="#FFC966", command=lambda: self.start_game("ultrasound")).place(x=screen_w // 2,
                                                                                                   y=screen_h // 2 + 20,
                                                                                                   anchor="center")
        tk.Button(self.root, text="Infrared Sensor", **btn_style, bg="#FFD700", fg="black", activebackground="#FFFF99",
                  command=lambda: self.start_game("infrared")).place(x=screen_w // 2, y=screen_h // 2 + 80,
                                                                     anchor="center")
        tk.Button(self.root, text="Retour", **btn_style, bg="#FF4C4C", fg="white", activebackground="#FF8888",
                  command=self.start_page).place(x=screen_w // 2, y=screen_h // 2 + 180, anchor="center")

    def regle(self):
        self.clear()
        screen_w = self.root.winfo_screenwidth()
        screen_h = self.root.winfo_screenheight()
        self.canvas = tk.Canvas(self.root, highlightthickness=0)
        self.canvas.pack(fill="both", expand=True)

        try:
            bg_img = Image.open("fondregles.png").resize((screen_w, screen_h), Image.Resampling.LANCZOS)
            self.bg_regle_img = ImageTk.PhotoImage(bg_img)
            self.canvas.create_image(0, 0, anchor="nw", image=self.bg_regle_img)
        except FileNotFoundError:
            self.canvas.config(bg="#2196F3")

        overlay = Image.new("RGBA", (int(screen_w * 0.55), int(screen_h * 0.5)), (0, 0, 0, 160))
        self.overlay_regle_img = ImageTk.PhotoImage(overlay)
        self.canvas.create_image(screen_w / 2, screen_h / 2, image=self.overlay_regle_img, anchor="center")

        self.canvas.create_text(screen_w / 2, screen_h * 0.28, text="Comment Jouer", font=("Arial", 32, "bold"),
                                fill="#FFD700")
        self.canvas.create_text(screen_w / 2, screen_h * 0.36,
                                text="Le but du jeu est simple :\nFais voler Goku sans qu‚Äôil touche les Kamehameha !",
                                font=("Arial", 16, "italic"), fill="white", justify="center")
        self.canvas.create_text(screen_w / 2, screen_h * 0.5,
                                text="‚Ä¢ Push Button : Appuie sur le bouton pour voler.\n‚Ä¢ Digital Encoder : Tourne l'encodeur pour voler.\n‚Ä¢ Ultrasound Sensor : Passe ta main au-dessus.\n‚Ä¢ Infrared Sensor : Passe ta main devant.",
                                font=("Arial", 18), fill="white", justify="left")
        self.canvas.create_text(screen_w / 2, screen_h * 0.64,
                                text="Si tu touches le sol ou un Kamehameha, c‚Äôest perdu !",
                                font=("Arial", 16, "italic"), fill="white", justify="center")

        tk.Button(self.root, text="Retour au menu", font=("Arial", 16, "bold"), bg="#FFD700", fg="black", relief="flat",
                  command=self.start_page).place(x=screen_w / 2, y=screen_h * 0.73, anchor="center")

    def start_game(self, mode):
        self.current_mode = mode
        self.game_page()
        self.stop_serial_thread()  
        self.init_serial_thread() 

    def game_page(self):
        self.clear()
        self.is_paused = False
        self.is_replay = False
        self.current_replay_data = []
        self.game_start_time = time.time()

        # --- RESET DU LISSAGE ---
        self.smooth_y = None

        self.canvas = tk.Canvas(self.root, highlightthickness=0)
        self.canvas.pack(fill="both", expand=True)
        self.screen_width = self.root.winfo_screenwidth()
        self.screen_height = self.root.winfo_screenheight()

        bg_img = Image.open("fond.png").resize((self.screen_width, self.screen_height), Image.Resampling.LANCZOS)
        self.bg_img = ImageTk.PhotoImage(bg_img)
        self.canvas.create_image(0, 0, anchor="nw", image=self.bg_img)

        self.ground = self.canvas.create_rectangle(0, self.screen_height - 50, self.screen_width, self.screen_height,
                                                   fill="#DEB887", outline="")

        self.bird_size = 100
        self.bird_x = 200
        self.bird_y = self.screen_height // 2
        img = Image.open("goku2.png").resize((self.bird_size, self.bird_size), Image.Resampling.LANCZOS)
        self.bird_img = ImageTk.PhotoImage(img)
        self.bird = self.canvas.create_image(self.bird_x, self.bird_y, anchor="nw", image=self.bird_img)

        self.pipes = []
        self.pipe_images = []
        x = self.bird_x + 500
        for i in range(5):
            self.create_pipe(x)
            x += random.randint(250, 400)

        self.passed_dict = {pipe[0]: False for pipe in self.pipes}
        self.score = 0
        self.score_text = self.canvas.create_text(self.screen_width - 50, 50, text=f"Score: 0",
                                                  font=("Arial", 24, "bold"), fill="white", anchor="ne")

        self.velocity = 0
        self.gravity = 1
        self.flap_strength = -15

        self.root.bind("<space>", self.on_space_press)
        self.game_loop_id = self.canvas.after(30, self.update_game)

    def create_pipe(self, x):
        gap = random.randint(180, 250)
        top_h = random.randint(100, self.screen_height - gap - 100)
        bottom_y = top_h + gap
        img_top = ImageTk.PhotoImage(Image.open("tuyau1.png").resize((100, top_h), Image.Resampling.LANCZOS))
        img_bot = ImageTk.PhotoImage(
            Image.open("tuyau2.png").resize((100, self.screen_height - bottom_y), Image.Resampling.LANCZOS))
        top = self.canvas.create_image(x, 0, anchor="nw", image=img_top)
        bot = self.canvas.create_image(x, bottom_y, anchor="nw", image=img_bot)
        self.pipes.append((top, bot))
        self.pipe_images.extend([img_top, img_bot])

    def move_pipes(self):
        speed = 16 if self.is_replay else 8
        bird_coords = self.canvas.coords(self.bird)
        if not bird_coords:
            return
        bird_x = bird_coords[0]

        for top, bot in list(self.pipes):  # copie s√©curis√©e
            self.canvas.move(top, -speed, 0)
            self.canvas.move(bot, -speed, 0)

        # ‚úÖ V√©rifie que la cl√© existe avant d'y acc√©der
            if (not self.is_replay and top in self.passed_dict
                and not self.passed_dict[top]
                and self.canvas.coords(top)[0] + 100 < bird_x):
                self.score += 1
                self.canvas.itemconfigure(self.score_text, text=f"Score: {self.score}")
                self.passed_dict[top] = True
                
                self.send_score_to_pic()

    # Suppression des anciens tuyaux
        if self.canvas.coords(self.pipes[0][0])[0] < -100:
            top, bot = self.pipes.pop(0)
            self.canvas.delete(top)
            self.canvas.delete(bot)
            if top in self.passed_dict:
                del self.passed_dict[top]
            new_x = self.canvas.coords(self.pipes[-1][0])[0] + random.randint(250, 400)
            self.create_pipe(new_x)

    def check_collision(self):
        bx1, by1, bx2, by2 = self.canvas.bbox(self.bird)
        if by1 <= 0 or by2 >= self.screen_height - 50: return True
        for top, bot in self.pipes:
            tx1, ty1, tx2, ty2 = self.canvas.bbox(top)
            bx1_p, by1_p, bx2_p, by2_p = self.canvas.bbox(bot)
            # Marges de collision r√©duites pour √™tre plus sympa
            if (bx2 - 30 > tx1 + 20 and bx1 + 30 < tx2 - 20 and by1 + 30 < ty2 - 20) or \
                    (bx2 - 30 > bx1_p + 20 and bx1 + 30 < bx2_p - 20 and by2 - 30 > by1_p + 20):
                return True
        return False

    def update_game(self):
        if self.is_paused:
            self.game_loop_id = self.canvas.after(30, self.update_game)
            return

        # --- MODIFICATION MAJEURE ICI ---
        # On n'applique la gravit√© QUE pour les modes "physiques"
        if self.current_mode in ["push_button","ultrasound"]:
            if not self.is_replay:
                self.velocity += self.gravity
                self.canvas.move(self.bird, 0, self.velocity)
                # Enregistre pour replay (temps, 'flap' n'est pas suffisant, il faut la position Y pour √™tre pr√©cis, ou juste les inputs)
                # Pour simplifier, on enregistre la position Y √† chaque frame pour le mode bouton aussi en replay
                self.current_replay_data.append((time.time() - self.game_start_time, self.canvas.coords(self.bird)[1]))

        # Pour les modes capteurs, la position Y est d√©j√† mise √† jour par 'read_pic' -> 'update_bird_from_sensor'

        # Clamp Y position (emp√™che de sortir de l'√©cran trop violemment)
        coords = self.canvas.coords(self.bird)
        if coords:
            y = coords[1]
            if y < 0:
                self.canvas.coords(self.bird, self.bird_x, 0); self.velocity = 0
            elif y > self.screen_height - 50 - self.bird_size:
                self.canvas.coords(self.bird, self.bird_x, self.screen_height - 50 - self.bird_size); self.velocity = 0

        self.move_pipes()
        if self.check_collision():
            self.end_game()
        else:
            self.game_loop_id = self.canvas.after(30 if not self.is_replay else 15, self.update_game)

    # --- REPLAY LOGIC ---
    def replay_game_page(self):
        if not self.last_replay_data:
            # Pas de replay dispo
            self.start_page()
            return

        self.clear()
        self.is_replay = True
        self.is_paused = False
        self.replay_index = 0
        self.game_start_time = time.time()

        # Setup sc√®ne (copie de game_page sans initialisation scores/serial)
        self.canvas = tk.Canvas(self.root, highlightthickness=0)
        self.canvas.pack(fill="both", expand=True)
        self.screen_width = self.root.winfo_screenwidth()
        self.screen_height = self.root.winfo_screenheight()
        bg_img = Image.open("fond.png").resize((self.screen_width, self.screen_height), Image.Resampling.LANCZOS)
        self.bg_img = ImageTk.PhotoImage(bg_img)
        self.canvas.create_image(0, 0, anchor="nw", image=self.bg_img)
        self.ground = self.canvas.create_rectangle(0, self.screen_height - 50, self.screen_width, self.screen_height,
                                                   fill="#DEB887", outline="")
        self.bird_size = 100
        self.bird_x = 200
        img = Image.open("goku2.png").resize((self.bird_size, self.bird_size), Image.Resampling.LANCZOS)
        self.bird_img = ImageTk.PhotoImage(img)
        # Position initiale du replay
        start_y = self.last_replay_data[0][1] if self.last_replay_data else self.screen_height // 2
        self.bird = self.canvas.create_image(self.bird_x, start_y, anchor="nw", image=self.bird_img)

        self.pipes = []
        self.pipe_images = []
        x = self.bird_x + 500
        for i in range(5):
            self.create_pipe(x)
            x += random.randint(250, 400)

        self.passed_dict = {pipe[0]: True for pipe in self.pipes}  # Pas de score en replay
        self.canvas.create_text(self.screen_width / 2, 50, text="REPLAY X2", font=("Arial", 30, "bold"), fill="red")

        self.update_replay()

    def update_replay(self):
        # Temps √©coul√© x2 pour acc√©l√©rer
        elapsed = (time.time() - self.game_start_time) * 2

        # Trouver la position Y correspondante au temps √©coul√©
        while self.replay_index < len(self.last_replay_data) - 1 and self.last_replay_data[self.replay_index + 1][
            0] < elapsed:
            self.replay_index += 1

        if self.replay_index < len(self.last_replay_data):
            y_pos = self.last_replay_data[self.replay_index][1]
            self.canvas.coords(self.bird, self.bird_x, y_pos)

        self.move_pipes()
        if self.check_collision() or self.replay_index >= len(self.last_replay_data) - 1:
            self.root.after(1000, self.start_page)  # Fin du replay
        else:
            self.game_loop_id = self.canvas.after(15, self.update_replay)  # Boucle plus rapide (15ms)

    def end_game(self):
        if self.game_loop_id: self.canvas.after_cancel(self.game_loop_id)

        # Sauvegarde le replay si ce n'√©tait pas d√©j√† un replay
        if not self.is_replay:
            self.last_replay_data = self.current_replay_data
            self.last_replay_mode = self.current_mode  # On pourrait aussi sauvegarder le mode

        if self.current_mode and self.score > self.best_scores[self.current_mode]:
            self.best_scores[self.current_mode] = self.score

        self.clear()
        self.canvas = tk.Canvas(self.root, highlightthickness=0)
        self.canvas.pack(fill="both", expand=True)
        screen_w = self.root.winfo_screenwidth()
        screen_h = self.root.winfo_screenheight()
        bg_img = Image.open("fond.png").resize((screen_w, screen_h), Image.Resampling.LANCZOS)
        self.bg_over_img = ImageTk.PhotoImage(bg_img)
        self.canvas.create_image(0, 0, anchor="nw", image=self.bg_over_img)
        overlay = Image.new("RGBA", (500, 450), (0, 0, 0, 180))
        self.overlay_go = ImageTk.PhotoImage(overlay)
        self.canvas.create_image(screen_w / 2, screen_h / 2, image=self.overlay_go, anchor="center")

        self.canvas.create_text(screen_w / 2, screen_h / 2 - 140, text="Game Over", font=("Arial", 40, "bold"),
                                fill="white")
        self.canvas.create_text(screen_w / 2, screen_h / 2 - 80, text=f"Score : {self.score}",
                                font=("Arial", 24, "bold"), fill="white")
        self.canvas.create_text(screen_w / 2, screen_h / 2 - 40,
                                text=f"Best ({self.current_mode}) : {self.best_scores.get(self.current_mode, 0)}",
                                font=("Arial", 24, "bold"), fill="white")

        btn_style = {"font": ("Arial", 16, "bold"), "relief": "flat", "padx": 15, "pady": 5, "width": 15}
        tk.Button(self.root, text="Restart", **btn_style, bg="#4CAF50", fg="white",
                  command=lambda: self.start_game(self.current_mode)).place(x=screen_w / 2, y=screen_h / 2 + 40,
                                                                            anchor="center")
        tk.Button(self.root, text="Menu", **btn_style, bg="#FFD700", fg="black", command=self.start_page).place(
            x=screen_w / 2, y=screen_h / 2 + 100, anchor="center")
        tk.Button(self.root, text="Quitter", **btn_style, bg="#FF4C4C", fg="white", command=self.quit_game).place(
            x=screen_w / 2, y=screen_h / 2 + 160, anchor="center")

    def on_space_press(self, event):
        if not self.is_paused and not self.is_replay and self.current_mode in ["push_button", "encoder","ultrasound"]:
            self.velocity = self.flap_strength

    def quit_game(self):
        self.clear()
        self.root.destroy()

    def clear(self):
        if self.blink_after_id: self.root.after_cancel(self.blink_after_id)
        if self.game_loop_id: self.root.after_cancel(self.game_loop_id)
        if self.goku_hover_id: self.root.after_cancel(self.goku_hover_id)
        self.stop_serial_thread()
        for widget in self.root.winfo_children():
            widget.destroy()


if __name__ == "__main__":
    root = tk.Tk()
    app = FlappyGUI(root)
    root.mainloop()
